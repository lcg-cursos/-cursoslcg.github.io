<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Python II y GitHub</title>
    <meta charset="utf-8" />
    <script src="libs/header-attrs-2.9/header-attrs.js"></script>
    <link href="libs/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/default-fonts.css" rel="stylesheet" />
    <link href="libs/remark-css-0.0.1/hygge.css" rel="stylesheet" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Python II y GitHub
### Licenciatura en Ciencias Genómicas, UNAM
### First version: 2021-08-03; Last update: 2021-08-10

---




&lt;style type="text/css"&gt;
/* From https://github.com/yihui/xaringan/issues/147  */
.scroll-output {
  height: 80%;
  overflow-y: scroll;
}
/* https://stackoverflow.com/questions/50919104/horizontally-scrollable-output-on-xaringan-slides */
pre {
  max-width: 100%;
  overflow-x: scroll;
}
&lt;/style&gt;


# Versionamiento en Git usando tags

## Contenido

1. [Especificar versiones en Git con tag](1-Etiquetas.html)

2. [Trabajar con ramas en Git: git branch](./leccion2/2-Ramas.html) 

3. [Pull Request con Git](./leccion2/3-PullRequest.html) 

4. [Manejo de un proyecto en GitHub](./leccion4/4-Proyecto.html)


---

## Objetivo
Al finalizar la lección, podremos identificar estados importantes de nuestro código, así como las liberaciones del mismo, mediante el uso de etiquetas en Git/GitHub.



&lt;img src="img/git-tags.png" width="250px" style="display: block; margin: auto;" /&gt;

---

## Introducción

Imaginemos que trabajamos en un proyecto de software para la clase de Python. A lo largo del desarrollo hemos invertido mucho tiempo en la solución del problema, lo que implica agregar nuevas funcionalidades e incluso modificar o corregir el código que ya hemos hecho (commits). 
&lt;img src="img/workFlow.png" width="550px" style="display: block; margin: auto;" /&gt;

Sin embargo, durante todo ese proceso, a veces quisieramos guardar una "foto" del **estado actual** de nuestro código, por considerarlo funcionable. Estas "fotos" las podemos llamar **versiones estables** de nuestro código. ¿y que podemos hacer con ellas? :

- Obtener resultados de versiones pasadas
- Ejecutar programas anteriores
- Rastreo de programas por fecha, commits.

---

#  tags : Etiquetando estados de código

.full-width[.content-box-blue[Los tag son una manera de etiquetar **estados** de tu repositorio, que se usa comúnmente para indicar las **versiones** o releases de un proyecto mantenido con Git.]]

.pull-left[

&lt;img src="img/tagsSchema.png" width="650px" style="display: block; margin: auto;" /&gt;


]

.pull-right[

- **Estados** importantes en la vida de un repositorio

- Usado principalmente para el manejo de las **releases** de un proyecto

- Permite mantener informados a los usuarios del código del software y otros desarrolladores de las **versiones** de una aplicación

]


---

## Git Tag 

El etiquetado es una herramienta fundamental para que el mismo programador, los usuarios, así como otros sistemas sepan cuándo el software ha cambiado y se permitan desencadenar procesos a ejecutar cada vez que esto ocurre.

.full-width[.content-box-red[Esta operación se conoce comúnmente con el nombre de **"tagging"**]]

Comando para crear etiquetas  

Sintaxis:

```
git tag
```


---
## Numeración de las versiones

- Git es un sistema de control de versiones

--

- Permite mantener todos los estados por los que ha pasado cualquiera de sus archivos

--

- Con **git tag** no nos referimos a la versión de un archivo en particular, sino de todo el proyecto de manera global

--

- **git tag** permite hacer referencia a un estado del **repositorio completo**, práctica que suele ocurrir cada vez que se libera una nueva versión del software

&lt;img src="img/tagging.png" width="500px" style="display: block; margin: auto;" /&gt;


---
## Numeración de las versiones

Las versiones de los proyectos las define el equipo de desarrollo, y se recomienda no crearlas de manera arbitraria, sino darles un significado real de acuerdo a las _modificaciones realizadas en el proyecto de software_.

&lt;img src="img/versions.png" width="250px" style="display: block; margin: auto;" /&gt;

---
## Numeración de las versiones

- Generalmente los cambios se pueden dividir en tres niveles de **"importancia": mayor, menor y pequeño ajuste** -&gt; versión **x**,**y**,**z**.

&lt;img src="img/desc-versiones.png" width="350px" style="display: block; margin: auto;" /&gt;

--

- x -&gt; si los cambios son tan grandes que cambian la forma en la que funcionaba tu software haciendo que ya no haya compatibilidad con la versión anterior

--

- y -&gt; si agregas una nueva funcionalidad que es compatible con tus versiones anteriores

--

- z -&gt; si lo que hiciste fue arreglar un bug


---
## Numeración de las versiones

 Por ejemplo: 

--

- Si tu proyecto estaba en la v0.0.1 y haces un _cambio que no altera la funcionalidad_ de trabajo entonces lo adecuado es versionar tu aplicación como v0.0.2.

--

- Si el proyecto ya tiene alguna modificación en funcionalidad, pero _sigue manteniendo completa compatibilidad con la versión anterior_, entonces tendremos que aumentar el segundo dígito, por ejemplo, pasar de la v1.0.0 a la v1.1.0.

--

- Si los **cambios** introducidos en el proyecto son tales _que impliquen una alteración sobre cómo se usará esa aplicación_, haciendo que no sea toltalmente compatible con versiones anteriores, entonces habría que aumentar en 1 la versión en su número más relevante, por ejemplo, pasar de la v1.1.5 a la v2.0.0.



.tiny[
Más información sobre [versionamiento semántico](https://semver.org/lang/es/)
]



---
## Crear un tag en Git

Hasta este momento hemos trabajado con un repositorio en Git, realizando cambios y enviandolos al servidor remoto, sin embargo, no tenemos ninguna numeración de versión y ningún tag que nos indique si el código ya se encuentra estable o si existe una nueva versión. 

Supongamos que empezamos por el número de versión **0.0.1**. Entonces para crear la correspondiente etiqueta usaremos el comando: 

Sintaxis:  

.full-width[.content-box-yellow[git tag [tag_name]]] 


Ejemplo:

.full-width[.content-box-yellow[git tag v0.0.1]]


Con esto estaremos etiquetando el estado actual del repositorio, el cual apunta al _último commit realizado_.

---
## Crear un tag en Git

Para poder definir una nueva etiqueta, será necesario realizar cambios al repositorio y confirmarlos mediante un commit.  

Para crear una segunda etiqueta:

.full-width[.content-box-yellow[git tag v0.0.2]]


---
## Consultar los estados de versiones en el repositorio con _git tag_

Una vez creado el primer tag en el repositorio, podremos ejecutar el comando "git tag", el cual nos informará sobre las versiones que hemos etiquetado hasta el momento.

Sintaxis:  

.full-width[.content-box-yellow[git tag]]

Resultado:  

.full-width[.content-box-yellow[$ git tag &lt;br&gt;
v0.0.1&lt;br&gt;
v0.0.2
]]


---
## Crear tags con mensaje

Crear etiquetas en Git es genial, pero necesitaremos agregar una descripción a la etiqueta que permita a los colaboradores (y a nosotros mismos) entender porqué fue creada.
Por ejemplo: no creamos un commit sin un mensaje, así que una etiqueta no debe crearse sin un mensaje.

.full-width[.content-box-yellow[git tag v0.0.3 -m "Tercera versión, cambios menores"]]


Consultar las etiquetas hasta el momento.

Resultado:

.full-width[.content-box-yellow[$ git tag &lt;br&gt;
v0.0.1&lt;br&gt;
v0.0.2&lt;br&gt;
v0.0.3  Se agregó logo de la LCG
]]

---
## Consultar una etiqueta en particular con _git show_

Otro comando interesante en el manejo de etiquetas es _git_ **show** _[tag_name]_. Este te permite conocer cómo estaba el repositorio en cada estado que has etiquetado, es decir, en cada versión.

.full-width[.content-box-yellow[git show v0.0.2]]

Resultado:

&lt;img src="img/show.png" width="450px" style="display: block; margin: auto;" /&gt;

---
## Desafio

Hemos trabajado mucho en nuestro repositorio de git llamado _python_class_ y ahora que tenemos una versión estable que queremos liberar necesitamos crear una etiqueta para identificarla. Para ello, realizamos los siguientes pasos:

1. Ir a una terminal 
--

2. Localizar tu repositorio Git de trabajo
--

3. Abrir el archivo "sequence.txt", modificarlo
.full-width[.content-box-yellow[git add sequence.txt]]
--

4. Crear una etiqueta
.full-width[.content-box-yellow[git tag v0.0.4]]
--

5. Revisar la etiqueta creada en el repositorio
.full-width[.content-box-yellow[git tag]]
--

**¿Este flujo de acciones será correcto?**



---
## Consideraciones


- Antes de modificar cualquier archivo revisa el estado de tu repositorio  
**git status**

--

- Si tienes cambios pendientes debes confirmarlos  
**git add**  
**git commit**  

--

- Recuerda agregar un mensaje cuando crees la etiqueta  
**git tag [tag_name] -m [mensaje]**

--

- Si quieres revisar una etiqueta en particular puedes definirlo  
**git show [tag_name]**

---
## Práctica
1. Abre una terminal y localiza tu repositorio de trabajo: python_class
--

2. Revisa el estado de tu repositorio. Asegurate que no haya nada pendiente por confirmar
.full-width[.content-box-yellow[git status]]
--

3. Abre el archivo "sequence.txt", modificalo y confirma los cambios
.full-width[.content-box-yellow[git add sequence.txt]]
.full-width[.content-box-yellow[git commit -m "Modificando el archivo sequence.txt"]]
--

4. Crea una etiqueta
.full-width[.content-box-yellow[git tag v0.0.1 -m "Archivo sequence completo y actualizado"]]
--

5. Revisa la etiqueta creada en el repositorio
.full-width[.content-box-yellow[git show v0.0.1]]


---


## Enviar etiquetas y hacer push de los commits al mismo tiempo

Hasta el momento todas las etiquetas que hemos creado han sido en nuestro repositorio local. Sin embargo, llevar estos cambios y las etiquetas al repositorio remoto es muy importante para que los usuarios de nuestros programas conozcan que existe una liberación de código.

Para ello, será necesario hacer un push a GitHub para enviar los cambios, así como _todas_ las etiquetas al mismo tiempo, utilizando el siguiente comando:

Sintaxis:  

.full-width[.content-box-yellow[git push origin master --tags]]


---



## Práctica

1-Envía los últimos cambios realizados en el repositorio local, así como la etiqueta recien creada al repositorio remoto

.full-width[.content-box-yellow[git push origin master --tags]]

2-Ve a GitHub y asegurate que los cambios realizados (commit) y la etiqueta se encuentren en el repositorio

---

## Enviar a GitHub una etiqueta en particular

Imaginemos que hacemos varias modificaciones (commits) al archivo "reverse-complement.py" y generamos distintas etiquetas para nuestro control interno. Sin embargo, cuando tenemos una versión estable deseamos llevar solo una de ellas al servidor remoto. Para ello usaremos el siguiente comando:

Sintaxis:  

.full-width[.content-box-yellow[git push origin master [tag_name]]]


Ejemplo:  

.full-width[.content-box-yellow[git push origin master v0.0.1]]


---


## Desafio

Jennifer ha realizado algunos cambios a sus scripts de Python y ha generado 3 tags (v0.0.1, v0.1.1 y v1.0.0) en su repositorio local para identificar aspectos relevantes de dichas modificaciones. 

¿Cuál de los siguientes comandos le permitiría a Jennifer enviar la etiqueta v1.0.0 y los últimos cambios al repositorio remoto en GitHub para compartirlo con sus compañeros?


.full-width[.content-box-yellow[a) git push origin master v1.0.0]]
.full-width[.content-box-yellow[b) git push origin v1.0.0]]
.full-width[.content-box-yellow[c) git push origin master --tags]]
.full-width[.content-box-yellow[d) git --tags master v1.0.0 ]]



---

## Desafio


La opción correcta es la "a", ya que indica exactamente la etiqueta a enviar, así como los cambios realizados. 

La opción "b" solo enviaría la etiqueta el repositorio remoto, pero no los cambios. 

La opción "c" y "d" son incorrectas en sintaxis.

---


## Práctica

1-Localiza el archivo "AT-percentage.py" y modifica la sección _AUTHOR_

--

2-Confirma los cambios:  
__git add__,  __git commit -m__

--

3-Crea una etiqueta con mensaje:  
__git tag [tag_name] -m "mensaje"__

--

4-Repite los pasos 1-3, modificando las sessiones _CATEGORY_ y _USAGE_ para crear dos etiquetas (v0.0.3 y v0.0.4)

--

5-Revisar las etiquetas creadas:  
__git tag__ o __git show [tag_name]__

--

6-Envía a GitHub solo una de las etiquetas creadas, así como su commit correspondiente:  
__git push origin master [tag_name]__


---

## Asociar una etiqueta a un commit en particular

Puede ser que tengamos commits previos que nos gustaría marcar por medio de etiquetas debido a que son muy importantes dentro de nuestro código.

Por lo general, cuando se crea una etiqueta, esta se encuentra asociada al último commit realizado; sin embargo, podemos especificar de manera particular el commit al que queremos marcar mediante una etiqueta.

Para ello usaaremos el comando:

Sintaxis:  

.full-width[.content-box-yellow[git tag -a [tag_name] [commit_id] -m "message"]]


Ejemplo:  

.full-width[.content-box-yellow[git tag -a v0.0.5 cab6e1b -m "Solución del bug en la lectura de la secuencia"]]


---

## Práctica

1-Ve al repositorio local y revisa la lista de commits

__git log --oneline__ 

--

2-Identifica el id del commit que quieres etiquetar

--

3-Crea la etiqueta para el commit seleccionado

__git tag -a [tag_name] [commit_id] -m "message"__

--

4-Revisar la etiqueta creada:  
__git tag__ o __git show [tag_name]__

---

## Eliminar una etiqueta local

Ahora que nos encontramos realizando etiquetas en nuestro repositorio, puede ser que comentamos algún error al momento de crearlas o simplemente queremos borrarlas. En caso de que se requiera eliminar una etiqueta, podemos hacer uso del comando:

.full-width[.content-box-yellow[git tag -d [tag_name]]]

--

 Ejemplo:

.full-width[.content-box-yellow[git tag -d v0.0.5]]

__Importante:__ La opción __-d__ es utilizada para borrar la etiqueta.

---
## Práctica


1-Realiza cambios en el archivo sequence.txt

--

2-Confirma los cambios:  
__git add__,  __git commit -m__

--

3-Crea una etiqueta con mensaje:  
__git tag [tag_name] -m "mensaje"__

--

4-Revisar las etiquetas creadas:  
__git tag__ o __git show [tag_name]__

--

5-Borra la etiqueta recíen creada:  
__git tag -d [tag_name]__

--


6-Verifica que la etiqueta haya sido eliminada localmente:  
__git tag__ o __git show [tag_name]__

---


## Eliminar una etiqueta remota

Hay que tomar en cuenta que en el paso anterior la etiqueta fue eliminada del repositorio local. Si la etiqueta se encontrara ya en el repositorio remoto (GitHub), para eliminarla debemos usar el siguiente comando:

.full-width[.content-box-yellow[git push --delete origin [tag_name]]]

--

 Ejemplo:

.full-width[.content-box-yellow[git push --delete origin v0.0.2]]


---

## Práctica


1-Revisa las etiquetas que actualmente se encuentran en tu repositorio remoto (GitHub):  
__Sección "tags"__

--

2-Identifica la etiqueta que deseas borrar y usa el comando:  
__git push --delete origin [tag_name]__

--

3-Revisar las etiquetas del repositorio remoto (GitHub):  
__Sección "tags"__

---

## Etiquetas desde GitHub

No solo desde Git podemos crear etiquetas, también desde nuestro repositorio remoto en GitHub tenemos la opción de generar etiquetas que indiquen las liberaciones del código.

En la página principal del repositorio, se encuentra la opción __releases__, donde se puede acceder a la información sobre las versiones etiquetadas en el proyecto, así como etiquetar nuevas versiones.


&lt;img src="img/github-tags.png" width="550px" style="display: block; margin: auto;" /&gt;

&lt;img src="img/new-tag.png" width="350px" style="display: block; margin: auto;" /&gt;

---

## Conclusión

Hemos aprendido a etiquetar estados de un proyecto con Git, algo que se realiza comúnmente para informar en el sistema de control de versiones de los **releases** principales durante la vida del software. Para trabajar las etiquetas en Git necesitamos conocer al menos los siguientes comandos:

.full-width[.content-box-yellow[git tag [tag_name] - m [mensaje]]]
.full-width[.content-box-yellow[git show [tag_name]]]
.full-width[.content-box-yellow[git tag -d [tag_name]]]


Puedes obtener más ayuda sobre opciones para el comando git tag con:  
__git tag -h__



---

    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="macros.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>
<style>
  .logo {
    background-image: url(img/LCG-UNAM.png);
    background-size: contain;
    background-repeat: no-repeat;
    position: absolute;
    top: 1em;
    right: 1em;
    width: 110px;
    height: 128px;
    z-index: 0;
  }
  </style>
  
  <script>
  document
    .querySelectorAll(
      '.remark-slide-content' +
      ':not(.title-slide)' +
      // add additional classes to exclude here, e.g.
      // ':not(.inverse)' +
      ':not(.hide-logo)'
    )
    .forEach(el => {
      el.innerHTML += '<div class="logo"></div>';
    });
  </script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
